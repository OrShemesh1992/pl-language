#lang pl
#|

Define the function plSuffixContained – that consumes a list of strings
and returns the first string that contains the string "pl" as a suffix – if one such
exists, and returns #f otherwise. For example, (plSuffixContained
‘("yyyt" "TplT" "plTT" "PlPl" "plplpl")) would return "
plplpl". Here is another example, written in a form of a test that you can
use:
(test (plSuffixContained ‘("pllp" "plyy" "ppp" "lpTT"
"lol")) => false)
Note: You may want to use pl procedures string-ref and string-
length.


(substring "Apple" 1 3)
(string-length "Apple")
(substring "Apple" 2)
(substring "Apple" (- (string-length "Apple") 2))
 (rest '(1 2 3 4 5 6 7 8 9 10))
(first '(1 2 3 4 5 6 7 8 9 10))
|#


(: plSuffixContained : (Listof String) -> Boolean)

(define(plSuffixContained lists)
  (cond [(null? lists) #f]
        [(<= (string-length (first lists)) 1) (plSuffixContained(rest lists))]
        [(equal? (substring (first lists) (- (string-length (first lists)) 2)) "pl") #t]
        [else (plSuffixContained(rest lists))]))

;tests
(test (plSuffixContained '("pllp" "plyy" "ppp" "lpTT" "lol")) => false)
(test (plSuffixContained '()) => false)
(test (plSuffixContained '("pl")) => true)
(test (plSuffixContained '("plllpl" "plyy" "ppp" "lpTT" "lol")) => true)
(test (plSuffixContained '("pllp" "pllyypl" "ppp" "lpTT" "lol")) => true)
(test (plSuffixContained '("pllp" "plyy" "ppp" "lpTT" "plopl")) => true)
(test (plSuffixContained '("pt" "l" "l" "pl")) => true)



#|
2.1.
Define a write-poly function that consumes a list of coefficients
(numbers) a 1 , a 2 , ... , a n and returns the polynomial (in a reversed order of
coefficients) "a 1 x n + a 2 x n-1 + ⋯ + a n ".Use only tail-recursion in your solution for this question. Again, make
sure that you write a proper contract, purpose statement, and tests.
(string-append "Apple" "Banana")
(string=? str1 str2 ...)
(string->number "-7")
(assert (string->number (car dlist)) exact-integer?)
|#

(: write-poly : (Listof Number) -> String)
(define (write-poly list)

  (write-poly-help list ""))


  (: write-poly-help : (Listof Number) String -> String)
  (define ( write-poly-help list str)

  (cond
    [(null? list) str]
 [(and (= (first list) 0) (string=? "" str) (= (length list) 1))
  (write-poly-help (rest list) (string-append str "0"))]
 
    [(= (first list) 0) 
  (write-poly-help (rest list) (string-append str ""))]
    
[(string=? "" str )
 (cond
      [(= (length list) 2)
      (write-poly-help (rest list) (string-append str (number->string (first list)) "x"))]
      [(= (length list) 1)
      (write-poly-help (rest list) (string-append str (number->string (first list))))]
      [else
      (write-poly-help (rest list) (string-append str (number->string (first list)) "x^" 
      (number->string (- (length list) 1))))])]



[(> (first list) 0)
 (cond
[(= (length list) 2)
 (write-poly-help (rest list) (string-append str "+" (number->string (first list)) "x"))]
[(= (length list) 1)
 (write-poly-help (rest list) (string-append str "+" (number->string (first list))))]
[else (write-poly-help (rest list) (string-append str "+" (number->string (first list)) "x^" 
(number->string (- (length list) 1))))])]

[else
  (cond
[(= (length list) 2)
 (write-poly-help (rest list) (string-append str (number->string (first list)) "x"))]
[(= (length list) 1)
 (write-poly-help (rest list) (string-append str (number->string (first list))))]
[else (write-poly-help (rest list) (string-append str (number->string (first list)) "x^" 
(number->string (- (length list) 1))))])]))



(test (write-poly '(3 2)) => "3x+2")
(test (write-poly '(3)) => "3")
(test (write-poly '(3 2 6)) => "3x^2+2x+6")
(test (write-poly '()) => "")
(test (write-poly '(7 8 9 10)) => "7x^3+8x^2+9x+10")
(test (write-poly '(-3 2 6)) => "-3x^2+2x+6")
(test (write-poly '(3 0 2)) => "3x^2+2")
(test (write-poly '(1 0 1)) => "1x^2+1")
(test (write-poly '(0 0 2)) => "2")
(test (write-poly '(0 1 2)) => "1x+2")
(test (write-poly '(3 -2 6)) => "3x^2-2x+6")
(test (write-poly '(-3 -2 6)) => "-3x^2-2x+6")
(test (write-poly '(8 9 -10 1)) =>"8x^3+9x^2-10x+1")
(test (write-poly '(2 0 0 0 0 6 -3)) =>"2x^6+6x-3")
(test (write-poly '(0 0 0)) => "0")

#|Define a compute-poly function that consumes a number x and a list of
coefficients (numbers) a 1 , a 2 , ... , a n and returns the result of the
polynomial (again, in a reversed order of coefficients) a 1 x n + a 2 x n-1 +
⋯ + a n applied to the first argument x (the natural number n is not given
to you).
(expt 2 3)
|#


(: compute-poly : Number (Listof Number) -> Number)
(define (compute-poly list x)

  (compute-poly-help x list 0))


  (: compute-poly-help : (Listof Number) Number Number -> Number)
  (define (compute-poly-help list x sum)

  (cond [(null? list) sum]

  [(= (length list) 1)
   (compute-poly-help (rest list) x (+ (first list) sum))]

[else (compute-poly-help (rest list) x (+ (* (first list) (expt x (- (length list) 1))) sum))])
)

(test (compute-poly -2 '(-4 -7)) => 1)
(test (compute-poly -1 '(-4 -7)) => -3)
(test (compute-poly 0 '(-4 -7)) => -7)
(test (compute-poly 1 '(-4 -7)) => -11)
(test (compute-poly 2 '(-4 -7)) => -15)
(test (compute-poly 2 '(-7)) => -7)
(test (compute-poly 2 '(7)) => 7)
(test (compute-poly 2 '()) => 0)
(test (compute-poly -2 '(3 2 6)) => 14)
(test (compute-poly -1 '(3 2 6)) => 7)
(test (compute-poly 0 '(3 2 6)) => 6)
(test (compute-poly 1 '(3 2 6)) => 11)
(test (compute-poly 2 '(3 2 6)) => 22)
(test (compute-poly 3 '(4 3 -2 0)) => 129)



(define-type Stack
  [EmptyKS]
  [Push Symbol String Stack]
 ; [search-stack Symbol Stack]
  )

(: search-stack : Symbol Stack -> (U String #f))
(define (search-stack Sym sta)

( cases sta  
[(Push sy str stack)
 (if (eq? sy Sym)
 str
 (search-stack Sym stack))]
[EmptyKS #f]
  ))


(: pop-stack : Stack -> (U Stack #f))
( define ( pop-stack sta)
( cases sta  
[(Push sy str stack) stack]
[EmptyKS #f]
  ))
(test (EmptyKS) => (EmptyKS))
(test (Push 'b "B" (Push 'a "A" (EmptyKS))) =>
(Push 'b "B" (Push 'a "A" (EmptyKS))))
(test (Push 'a "AAA" (Push 'b "B" (Push 'a "A" (EmptyKS))))
=> (Push 'a "AAA" (Push 'b "B" (Push 'a "A" (EmptyKS)))))
(test (search-stack 'a (Push 'a "AAA" (Push 'b "B" (Push 'a
"A" (EmptyKS))))) => "AAA")
(test (search-stack 'c (Push 'a "AAA" (Push 'b "B" (Push 'a
"A" (EmptyKS))))) => #f)
(test (search-stack 'a (EmptyKS)) => #f)
(test (pop-stack (Push 'a "AAA" (Push 'b "B" (Push 'a "A"
(EmptyKS))))) => (Push 'b "B" (Push 'a "A" (EmptyKS))))
(test (pop-stack (EmptyKS)) => #f)




#|
In this question you are given full code together with tests for the presented
functions. All you are required to do is to add the appropriate comments for
each of the functions. These comments should describe what the function
takes as input, what it outputs, what its purpose is, and how it operates. Do
not forget to also add your personal remarks on the process in which you
personally came to realize the above. You should copy the following code into
your .rkt file, and add the comment therein.
|#

(: is-odd? : Natural -> Boolean)
;; << Add your comments here>>
;; << Add your comments here>>
(define (is-odd? x)
(if (zero? x)false
(is-even? (- x 1))))
(: is-even? : Natural -> Boolean)
;; << Add your comments here>>
;; << Add your comments here>>
(define (is-even? x)
(if (zero? x)
true
(is-odd? (- x 1))))
;; tests --- is-odd?/is-even?
(test (not (is-odd? 12)))
(test (is-even? 12))
(test (not (is-odd? 0)))
(test (is-even? 0))
(test (is-odd? 1))
(test (not (is-even? 1)))
(: every? : (All (A) (A -> Boolean) (Listof A) -> Boolean))
;; See explanation about the All syntax at the end of the file...
;; << Add your comments here>>
;; << Add your comments here>>
(define (every? pred lst)
(or (null? lst)
(and (pred (first lst))
(every? pred (rest lst)))))
;; An example for the usefulness of this polymorphic function
(: all-even? : (Listof Natural) -> Boolean)
;; << Add your comments here>>
;; << Add your comments here>>
(define (all-even? lst)
(every? is-even? lst))
;; tests
(test (all-even? null))
(test (all-even? (list 0)))
(test (all-even? (list 2 4 6 8)))
(test (not (all-even? (list 1 3 5 7))))
(test (not (all-even? (list 1))))
(test (not (all-even? (list 2 4 1 6))))